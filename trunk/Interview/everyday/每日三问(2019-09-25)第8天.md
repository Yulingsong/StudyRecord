#####学习github上 [fe-interview](https://github.com/haizlin/fe-interview)，每日三问，慢慢积累。



## 一：简述下html5的离线储存原理，同时说明如何使用？

###原理：

HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

###如何使用：

- 页面头部像下面一样加入一个manifest的属性。

    <!DOCTYPE HTML>
    <html manifest = "cache.manifest">
    	...
    </html>

- 在cache.manifest文件的编写离线存储的资源。

    CACHE MANIFEST
        	#v0.1
        	CACHE:
       	 		js/index.js
        		css/index.css
        	NETWORK:
        		images/logo.png
        	FALLBACK:
        		*.html /404.html /* / /404.html 或 /html/ /404.html 也可*/

以#号开头的是注释，一般会在第二行写个版本号，用来在缓存的文件更新时，更新manifest以实现浏览器重新下载新的文件，可以是版本号，时间戳或md5码等。

###离线存储的manifest一般由三个部分组成：

- CACHE：必选，表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。

- NETWORK：可选，可以使用通配符，表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。

- FALLBACK：可选，表示如果访问第一个资源失败，那么就使用第二个资源来替换他，如/html/ /404.html表示用 “404.html” 替代 /html/ 目录中的所有文件，/ /404.html表示用 “404.html” 替代当前目录中的所有文件，*.html /404.html表示用 “404.html” 替代 所有html文件。 

###浏览器如何对离线存储的资源进行管理和加载：

- 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。

- 离线的情况下，浏览器就直接使用离线存储的资源。

####注意：

- 引用manifest的html必须与manifest文件同源，在同一个域下，FALLBACK中的资源也必须和manifest文件同源。

- 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问。

- 如果服务器对离线的资源进行了更新，那么必须更新manifest文件（如更新manifest的版本等）之后这些资源才能被浏览器重新下载，如果只是更新了资源而没有更新manifest文件的话，浏览器并不会重新下载资源，也就是说还是使用原来离线存储的资源。

- 浏览器在下载manifest文件中的资源的时候，它会一次性下载所有资源，如果某个资源由于某种原因下载失败，那么这次的所有更新就算是失败的，浏览器还是会使用原来的资源。

- 更新了资源后，新的资源要到下次再访问网页时才会生效，出现这种现象的原因是浏览器会先使用离线资源加载页面，再去检查manifest是否有更新，所以要到下次打开页面才能生效。如果需要资源马上就能生效，那么可以使用window.applicationCache.swapCache()方法来使之生效。

###更新缓存的三种方式：

- 更新manifest文件

1)给manifest添加或删除文件。

2)若manifest没有添加或删除文件，只是修改了文件，可以通过更改版本号等更新manifest文件。

- 通过javascript操作

html5中引入了js操作离线缓存的方法：window.applicationCache.update()，可以手动更新缓存。

- 清除浏览器缓存

如果用户清除了浏览器缓存（手动或用其他一些工具），都会重新下载文件。



## 二：清除浮动的方式有哪些及优缺点？

####1.使用空标签清除浮动clear:both。

**原理**：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度

**优点**：**通俗易懂，容易掌握**

**缺点**：**会添加很多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦**

**建议**：不推荐使用，但此方法是以前主要使用的一种清除浮动方法

####2.父级div定义overflow:hidden。

**原理**：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度

**优点**：**简单，代码少，浏览器支持好**

**缺点**：**不能和position配合使用，因为超出的尺寸的会被隐藏**

**建议**：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用

####3.父级div定义伪类:after和zoom(用于非IE浏览器)

**原理**：IE8以上和非IE浏览器才支持:after，原理和方法1有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题

**优点**：**浏览器支持好**，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）。

**缺点**：**代码多**，要两句代码结合使用，才能让主流浏览器都支持

**建议**：推荐使用，建议定义公共类，以减少CSS代码

####4.父级div定义height。

**原理**：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。

**优点**：**简单，代码少，容易掌握**

**缺点**：**只适合高度固定的布局**，要给出精确的高度，如果高度和父级div不一样时，会产生问题

####5.父级div定义overflow:auto

**原理**：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度

**优点**：**简单，代码少，浏览器支持好**

**缺点**：**内部宽高超过父级div时，会出现滚动条**。

**建议**：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。



## 三：写一个加密字符串的方法

```js
function strEncrypt(str) {
  return str.split('').map(s => {
    return String.fromCharCode(s.charCodeAt() + 1)
  }).join('')
}

console.log(strEncrypt('hello world')) // ifmmp!xpsme
```


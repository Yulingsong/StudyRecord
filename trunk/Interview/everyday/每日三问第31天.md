#####学习github上 [fe-interview](https://github.com/haizlin/fe-interview)，每日三问，慢慢积累。

## 一：HTML与XHTML二者有不同

###最主要的不同：

- XHTML 元素必须被正确地嵌套。
- XHTML 元素必须被关闭。
- 标签名必须用小写字母。
- XHTML 文档必须拥有根元素。



## 二：写出主流浏览器内核私有属性的css前缀            

- Chrome：Blink内核   -webkit-
-  Safari：WebKit内核    -webkit-
-  Firefox ：Gecko内核    -moz-
-  IE：Trident内核         -ms-
-  Opera：Presto内核     -o-



## 三：前端安全之XSS和CSRF攻击的原理和解决方案

####1、XSS（CRoss Site Scripting, 跨站脚本攻击）

这是前端最常见的攻击方式，很多大型网站（如Facebook）都被XSS攻击过。

举个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文、和图片，完全没有问题。但是如果我写的是恶意的JS脚本，例如获取到document。cookie然后传输到自己的服务器上，那我这篇文章或者评论时，之前注入的这段JS代码就执行了。JS代码一旦执行，那可就不受控制了，因为它跟网页原有的JS有同样的权限，例如可以获取server端数据、可以获取cookie等。于是，攻击就这样发生了。
XSS的危害

XSS的危害想当大，如果页面可以随意执行别人不安全的JS代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。

比如早些年社交网站经常曝出XSS蠕虫，通过发布的文章内插入JS，用户访问了感染不安全JS注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入每个用户的文章列表面前，很快就会造成大规模的感染。

还有利用cookie的方式，将cookie传入入侵者的服务器上，入侵者就可以模拟cookie登陆网站，对用户的信息进行篡改。
预防XSS攻击

那么如何预防XSS攻击呢？最根本最有效的方法就是对用户输入的内容进行验证和替换，这样的话即便用户恶意输入一些指令，也会被替换为其他不可执行的字符，需要替换的字符有：

    & 替换 为: &amp;
    < 替换为 &lt；
    > 替换为&gt ;
    ‘’ 替换为 &quot;
    ’ 替换为 &#x27;
    / 替换为 &#x2f;
    替换了这些字符之后，黑客输入的攻击代码就会失效，XSS攻击将不会轻易发生。

除此之外，还可以通过对cookie进行较强的控制，比如对敏感的cookit增加http-only限制，让JS获取不到cookie内容。

####2、CSRF(Cross-site request forgery, 跨域请求伪造)

####CSRF攻击攻击原理及过程如下：

- 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
- 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
- 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
- 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
- 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行

####防范措施

- 对于web站点，将持久化的授权方法（例如cookie或者HTTP授权）切换为瞬时的授权方法（在每个form中提供隐藏field），这将帮助网站防止这些攻击。一种类似的方式是在form中包含秘密信息、用户指定的代号作为cookie之外的验证。
- 另一个可选的方法是“双提交”cookie。此方法只工作于Ajax请求，但它能够作为无需改变大量form的全局修正方法。如果某个授权的cookie在form post之前正被JavaScript代码读取，那么限制跨域规则将被应用。如果服务器需要在Post请求体或者URL中包含授权cookie的请求，那么这个请求必须来自于受信任的域，因为其它域是不能从信任域读取cookie的。
- 与通常的信任想法相反，使用Post代替Get方法并不能提供卓有成效的保护。因为JavaScript能使用伪造的POST请求。尽管如此，那些导致对安全产生“副作用”的请求应该总使用Post方式发送。Post方式不会在web服务器和代理服务器日志中留下数据尾巴，然而Get方式却会留下数据尾巴。
  尽管CSRF是web应用的基本问题，而不是用户的问题，但用户能够在缺乏安全设计的网站上保护他们的帐户：通过在浏览其它站点前登出站点或者在浏览器会话结束后清理浏览器的cookie。



## 四：前端性能优化方案有哪些

### 客户端优化

- 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。
- 使用CSS雪碧图（CSS Sprites）CSS Sprites一句话：将多个图片合并到一张单独的图片，这样就大大减少了页面中图片的HTTP请求。
- 减少DOM操作次数，优化javascript性能。
- 少用全局变量、减少DOM操作、缓存DOM节点查找的结果。减少IO读取操作。
- 延迟加载 | 延迟渲染
- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。
- 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。

### 服务端优化

- 尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，压缩 css 和 js；或加快文件读取速度，优化服务端的缓存策略。
- 客户端优化 dom、css 和 js 的代码和加载顺序；或进行服务器端渲染，减轻客户端渲染的压力。
- 优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。

　对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。
 　减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。

涉及的知识点太多，从客户端浏览器、渲染机制、缓存、 网络请求、代码压缩合并、图片格式、服务器代理、数据库的查询.....



## 五：html5哪些标签可以优化SEO?

- meta description
- title
- alt
- strong
- h1~h6
- header
- nav
- section
- aside
- article
- footer
- figure



## 六：说说你对cookie和session的理解            

cookie: 可以通过客户端, 服务端设置, 容量小, 可以通过设置domain来实现同步登录, 除了name, value,  它还有多个选项, domain, path, secure, expires, 客户端和服务端可以通过cookie来通讯, 传递信息

session: 由服务端设置并发起, 是服务端对于用户行为的一种凭证, 通常也是由cookie来维持这种关系, 比如session_id, 或者现在webstorm设置的`Webstorm-bb00fc34`等! 通过这种维持两者的关系,



## 七：实现单行文本居中和多行文本左对齐并超出显示"..."

```css
.one {
  text-align: center
}

.multi {
  overflow: hidden
  text-overflow: ellipsis
  display: -webkit-box
  -webkit-line-clamp: 3
  -webkit-box-orient: vertical
}
```



## 八：说说你对eval的理解

- 不安全的,
- 容易出错, 因为你不知道你传入的参数是什么鬼
- 性能底下.
- 某种情况下跟new Function(), setTimeout, setInterval类似
- 不利于代码可维护性, 可拓展性
- 不是在无可奈何的情况下, 请不要使用

 `eval()` 相当于一个小型的js解析器，接受一个字符串，可以把字符串解析成js代码并执行，所以有很有大的安全隐患，并且写进去的代码都是字符串，不利于维护，使用它执行代码性能也会大大折扣，所以正常情况下不建议使用。

## 九： title与h1、b与strong、i与em的区别分别是什么？

- `title`标签写在body里面不会被渲染,只能写在head里面,对网站SEO比较重要
- `h1`标签写在body里面,但是写在head里(不推荐),渲染的时候会自动渲染到body里面去
- `b`标签与`strong`标签在表现上是一样的,都自带`font-weight: bold`属性
- `i`标签与`em`标签在表现上是一样的,都自带`font-style: italic`属性
- `b`标签与`i`标签是物理标记,告诉浏览器以何种格式显示文字
- `strong`标签与`em`标签是逻辑标记,逻辑元素告诉浏览器这些文字有怎么样的重要性

> - **b**: bold ;
> - **strong**: strong ;
> - **i**: Italic ;
> - **em**: emphasize;



## 十：写出你知道的CSS水平和垂直居中的方法

https://xiangshuo.blog.csdn.net/article/details/86539582



## 十一：公钥加密和私钥加密是什么？

私钥加密，也称对称加密，使用一个密钥对内容进行加密和解密，加密算法可以是公开的，但密钥必须保密，常见的私钥加密算法有：DES、AES、RC5

公钥加密，也称非对称加密，使用两个密钥，一个公开密钥用来加密，另一个私有密钥用来解密，基于其特性，可以用作数字签名的功能（如 HTTPS），常见的公钥加密算法有：RSA



## 十二： html5都有哪些新的特性？移除了哪些元素？

#### 新增特性

- canvas
- svg
- video
- drag & drop
- localStorage/sessionStorage
- 语义化标签: header/nav/section/article/footer
- input 类型: date/datetime/email/range

#### 移除元素

- applet
- big
- font
- frame/frameset

## 十三： 怎么才能让图文不可复制？

```css
-webkit-user-select: none;
-ms-user-select: none;
-moz-user-select: none;
-khtml-user-select: none;
user-select: none;
```



## 十四： 为什么会有跨域问题？怎么解决跨域？

### 什么是跨域

Ajax 的便利性大家都清楚，可以在不向服务器提交完整的页面的情况下，实现局部更新页面。但是浏览器处于对安全方面的考虑，不允许跨域调用其他页面的对象。
 其实这个也不能怪浏览器，假设谁都可以随随便便向你发送请求，那样有很大的安全隐患。
 根据浏览器的同源策略, 只有当协议，域名，端口相同的时候才算是同源, 反之则均视为是一个跨域的请求.
 也就是说我刚刚的Vue端口是`8081`，服务端端口是`8080`，端口不一样，因为同源策略的存在 ，所有我的请求会失败。

## 怎么解决跨域

#### JSONP

优点是可以兼容老浏览器，缺点是只能发送GET请求

#### CORS

优点简单方便，支持post请求，缺点是需要后端的配合,不支持老版浏览器。。

#### Server Proxy

优点是前端正常发送ajax请求，缺点是后端会二次请求。

其他的跨域方式还有：`location.hash`、`window.name`、`postMessage`等方式，有时间也可以了解一下。

